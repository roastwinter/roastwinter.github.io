<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>焦 | 焦</title><meta name="author" content="Hou"><meta name="copyright" content="Hou"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="13 Java 数据结构 数据结构分为两种：线性结构、非线性结构  线性结构：  最常用的数据结构。数据元素间存在一对一线性关系。  线性结构有 2 种不同的存储结构：顺序储存结构，链式储存结构 顺序存储结构中元素存储在连续的内存空间中。 链式储存结构中元素储存在非连续的空间中，元素节点中存放数据元素及相邻元素的地址信息  常见的线性结构有：数组、队列、链表、栈等   非线性结构：  非线性结构包">
<meta property="og:type" content="article">
<meta property="og:title" content="焦">
<meta property="og:url" content="http://example.com/2023/09/22/%E9%9B%86%E5%90%88/index.html">
<meta property="og:site_name" content="焦">
<meta property="og:description" content="13 Java 数据结构 数据结构分为两种：线性结构、非线性结构  线性结构：  最常用的数据结构。数据元素间存在一对一线性关系。  线性结构有 2 种不同的存储结构：顺序储存结构，链式储存结构 顺序存储结构中元素存储在连续的内存空间中。 链式储存结构中元素储存在非连续的空间中，元素节点中存放数据元素及相邻元素的地址信息  常见的线性结构有：数组、队列、链表、栈等   非线性结构：  非线性结构包">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/tx.jpg">
<meta property="article:published_time" content="2023-09-22T12:37:22.142Z">
<meta property="article:modified_time" content="2023-09-27T06:46:54.470Z">
<meta property="article:author" content="Hou">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/tx.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/09/22/%E9%9B%86%E5%90%88/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '焦',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-27 14:46:54'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="焦" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/tx.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="焦"><span class="site-name">焦</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> Gallery</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-22T12:37:22.142Z" title="发表于 2023-09-22 20:37:22">2023-09-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-27T06:46:54.470Z" title="更新于 2023-09-27 14:46:54">2023-09-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="13-Java-数据结构"><a href="#13-Java-数据结构" class="headerlink" title="13 Java 数据结构"></a>13 Java 数据结构</h1><blockquote>
<p>数据结构分为两种：线性结构、非线性结构</p>
</blockquote>
<p><strong>线性结构：</strong></p>
<ul>
<li><p>最常用的数据结构。数据元素间存在一对一线性关系。</p>
</li>
<li><p>线性结构有 2 种不同的存储结构：顺序储存结构，链式储存结构</p>
<p>顺序存储结构中元素存储在连续的内存空间中。</p>
<p>链式储存结构中元素储存在非连续的空间中，元素节点中存放数据元素及相邻元素的地址信息</p>
</li>
<li><p>常见的线性结构有：数组、队列、链表、栈等</p>
</li>
</ul>
<p><strong>非线性结构：</strong></p>
<ul>
<li>非线性结构包括：二维数组、多维数组、广义表、树结构、图结构</li>
</ul>
<h2 id="13-1-集合的框架体系"><a href="#13-1-集合的框架体系" class="headerlink" title="13.1 集合的框架体系"></a>13.1 集合的框架体系</h2><blockquote>
<p>Java 提供了一系列集合容器，以方便程序员动态保存元素。并提供了一系列方便的操作对象的方法。</p>
<p>Java 集合主要分为两组：单列集合（Collection）、双列集合（Map）</p>
</blockquote>
<ul>
<li><p><strong>Collection 接口</strong>（单列集合）：可以存放多个元素。每个元素可以是 Object</p>
<p>Collection 接口有两个重要子接口：List（有序集合）和 Set（无序集合）</p>
</li>
<li><p><strong>Map 接口</strong>（双列集合）：用于保存具有映射关系的数据：key - value（双列元素）</p>
<p>key 和 value 可以是任何类型的引用数据类型。其中 key 不能重复，value 可以重复</p>
<p>key 和 value 存在单一对应关系。通过特定的 key 一定能找到指定的 value</p>
</li>
</ul>
<img src="C:\Users\18356\AppData\Roaming\Typora\typora-user-images\image-20230921153457740.png" alt="image-20230921153457740" style="zoom: 50%;" />

<img src="C:\Users\18356\AppData\Roaming\Typora\typora-user-images\image-20230921153425201.png" alt="image-20230921153425201" style="zoom: 67%;" />

<h2 id="13-2-单列集合接口-Collection"><a href="#13-2-单列集合接口-Collection" class="headerlink" title="13.2 单列集合接口 Collection"></a>13.2 单列集合接口 Collection</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Lterable</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Collection 实现子类可以存放多个元素。每个元素可以是 Object</p>
<p>有些 Collection 实现子类能存放重复的元素，有些不能</p>
<p>有些 Collection 实现子类是有序的（List） ，有些不是（Set）</p>
<p>Collection 接口没有直接的实现子类，都是通过其子接口实现的</p>
</blockquote>
<h3 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h3><ul>
<li><p><code>add</code>：添加单个元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;哈哈哈&quot;</span>);</span><br><span class="line">list.add(<span class="number">10</span>);				<span class="comment">// 相当于List.add(new Integer(10));</span></span><br><span class="line">list.add(<span class="literal">true</span>);				<span class="comment">// 同上</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>remove</code>：删除单个元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.remove(<span class="number">0</span>)				<span class="comment">// 删除编号 0 的元素。上例中会删除 &quot;哈哈啊&quot;</span></span><br><span class="line">list.remove((Integer)<span class="number">10</span>);	<span class="comment">// 删除上例的 10 要这样写</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>contains</code>：检查元素是否存在</p>
</li>
<li><p><code>size</code>：获取元素个数</p>
</li>
<li><p><code>isEmpty</code>：判断是否为空</p>
</li>
<li><p><code>clear</code>：清空</p>
</li>
<li><p><code>addAll</code>：添加多个元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list2.add(<span class="number">111</span>);</span><br><span class="line">list2.add(<span class="string">&quot;idea&quot;</span>);</span><br><span class="line">list.addAll(list2);		<span class="comment">// 这里可以输入所有实现了 Collection 接口的集合</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>containsAll</code>：检查多个元素是否存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.contaionsAll(list2);	<span class="comment">// 同上，放一个实现了 Collection 接口的集合</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>removeAll</code>：删除多个元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.removeAll(list2);		<span class="comment">// 同上</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Iterator iterator()</code>：返回指向集合开始位置的迭代器</p>
</li>
</ul>
<h3 id="13-2-1-迭代器-Iterator"><a href="#13-2-1-迭代器-Iterator" class="headerlink" title="13.2.1 迭代器 Iterator"></a>13.2.1 迭代器 Iterator</h3><blockquote>
<p>Iterator 对象称为迭代器，主要用于遍历 Collection 集合中的元素。</p>
<p>Collection 继承的 Iterable 接口中，提供了 <code>iterator()</code> 方法，会返回一个新的迭代器。</p>
<p>Iterator 对象仅用于遍历集合，本身不存放元素</p>
<p>IDEA 中，迭代器 while 循环的模板快捷键：<code>itit</code></p>
</blockquote>
<p><strong>常用方法：</strong></p>
<ul>
<li><code>boolean hasNext()</code>：该方法判断是否有下一个元素。</li>
<li><code>T next()</code>：该方法会将指针下移，然后返回下移后的位置上的元素</li>
</ul>
<p><strong>用迭代器遍历元素：</strong>(快捷键：<code>itit</code> &#x2F; <code>I</code>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;Object&gt; c = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">Iterator&lt;Object&gt; iterator = c.iterator();		<span class="comment">// [1]</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;						<span class="comment">// [2]</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();				<span class="comment">// [3]</span></span><br><span class="line">	System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>获取迭代器</p>
</li>
<li><p>判断有无下一元素</p>
</li>
<li><p>将迭代器后移，并返回那个后移位置上的元素</p>
<p>while 循环结束后，指针指向最后元素的位置。再次 <code>next()</code> 会报错。如果需要再使用，需要重置迭代器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iterator = list.iterator();				<span class="comment">// 重置了迭代器</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>for each（增强 for 循环）：</strong></p>
<blockquote>
<p>for each 的语法与 for 循环相似，但是可以遍历 Collection 和 数组 中的元素</p>
<p>IDEA 中，增强 for 循环的模板快捷键：<code>iter</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Object o : list)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>for each 可在 Collection 集合中使用。</li>
<li>for each 的底层在本质上也是 <code>Iterator</code>。可以理解为简化版本的迭代器遍历。</li>
</ul>
<p><strong>普通for：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="13-3-有序集合接口-List"><a href="#13-3-有序集合接口-List" class="headerlink" title="13.3 有序集合接口 List"></a>13.3 有序集合接口 List</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>List 是 Collection 接口的子类接口</p>
<p>List 是有序（添加顺序和取出顺序一致）的，可重复的</p>
<p>List 中的每个元素都有其对应的顺序索引（从 0 开始编号）</p>
</blockquote>
<h3 id="常用方法：-1"><a href="#常用方法：-1" class="headerlink" title="常用方法："></a>常用方法：</h3><ul>
<li><p><code>add(int, obj)</code>：在 int 位置插入 obj 元素。返回 true</p>
<p><code>add(obj)</code>：在末尾插入 obj。返回 true</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.add(<span class="number">111</span>);</span><br><span class="line">list.add(<span class="number">0</span>, <span class="number">110</span>);						<span class="comment">// 在第 1 个位置插入数字 110</span></span><br></pre></td></tr></table></figure>

<p><code>addElement(obj)</code>：在末尾插入 obj。无返回值。你说要这方法有啥用？名字还长一截</p>
</li>
<li><p><code>addAll(int, collection)</code>：在 int 位置插入 collection 中的所有元素</p>
</li>
<li><p><code>get(int)</code>：返回 int 位置的元素</p>
</li>
<li><p><code>indexOf(obj)</code>：返回 obj 首次出现时的位置</p>
</li>
<li><p><code>lastIndexOf(obj)</code>：返回 obj 最后一次出现时的位置</p>
</li>
<li><p><code>remove(int)</code>：移除 int 位置的元素，并返回那个被移除的元素</p>
</li>
<li><p><code>set(int, obj)</code>：设置 int 位置的元素为 obj。相当于替换。返回那个被替换元素的下标</p>
<p><code>setElement(obj, int)</code>：设置 int 位置的元素为 obj。无返回值</p>
</li>
<li><p><code>subList(int1, int2)</code>：返回 [int1, int2) 范围的元素构成的子集合</p>
</li>
</ul>
<h3 id="13-3-1-可变数组-ArrayList"><a href="#13-3-1-可变数组-ArrayList" class="headerlink" title="13.3.1 可变数组 ArrayList"></a>13.3.1 可变数组 ArrayList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">     <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ArrayList 是 List 的实现子类。其底层由数组来实现存储。</p>
<p>ArrayList 可以存放 null</p>
</blockquote>
<h4 id="ArrayList-的源码：-没看"><a href="#ArrayList-的源码：-没看" class="headerlink" title="#ArrayList 的源码：&#x2F;&#x2F;没看"></a>#ArrayList 的源码：&#x2F;&#x2F;没看</h4><ol>
<li><p>ArrayList 中维护了一个 Object 类型的数组 elementData。该数组就是用来存放元素的数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 ArrayList 对象时，如果使用无参构造器，则 elementData[] 初始容量为 0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果使用指定大小构造器，则初始容量为指定大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">/* 这个场合，与默认构造器的不同之处在于</span></span><br><span class="line"><span class="comment">		扩容时，该 0 容量变为 1，而默认构造器会变为 10 */</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>扩容的场合：</p>
<p>如果是 <strong>无参构造器生成的初始 0 长度的 elementData</strong>，则将其容量置为 10。</p>
<p>否则容量扩容为 1.5 倍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 扩容方法，传入的参数 minCapacity 是容器现有元素数量 + 1 的值</span></span><br><span class="line"><span class="comment">	如果是无参构造器生成的默认数组，此时传入固定值 10 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">/* 计算新的容量（旧容量的 1.5 倍）</span></span><br><span class="line"><span class="comment">    	此处 &gt;&gt; 为位运算符，等同于 newC = oldC + oldC / 2; */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* 这里如果原容量是特殊值（1 或 0），容量会变为那个 minCapacity 的值 */</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="13-3-2-可变数组-Vector"><a href="#13-3-2-可变数组-Vector" class="headerlink" title="13.3.2 可变数组 Vector"></a>13.3.2 可变数组 Vector</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vector</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Vector 是 List 的实现子类。其底层由数组来实现存储</p>
<p>Vector 与 ArrayList 基本等同。ArrayList 效率更高，Vector 线程安全。</p>
<p>在开发中，需要考虑线程安全时，建议使用 Vector ，而非 ArrayList。</p>
</blockquote>
<h4 id="Vector-的源码："><a href="#Vector-的源码：" class="headerlink" title="#Vector 的源码："></a>#Vector 的源码：</h4><ol>
<li><p>底层维护了一个 Object 类型的数组 elementData。用以存放元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] elementData;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用无参构造器创建对象时，默认大小是 10</p>
<p>使用有参构造器的场合，默认是那个指定大小（initialCapaticy）</p>
<p>也能在构造器中指定那个扩容的增长速度（capacityIncrement）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">int</span> capacityIncrement)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(...);</span><br><span class="line">    <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    <span class="built_in">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>扩容的场合，容量变成 2 倍</p>
<p>使用有参构造器改变了 capacityIncrement 的场合，增量是那个指定数值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">/* 计算新的容量（按照指定的增速扩容）</span></span><br><span class="line"><span class="comment">    	那个指定无效或未指定时，容量变为 2 倍 */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="13-3-3-链表-LinkedList"><a href="#13-3-3-链表-LinkedList" class="headerlink" title="13.3.3 链表 LinkedList"></a>13.3.3 链表 LinkedList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 Java 中，LinkedList 是 List 的实现子类，底层以链表形式存储元素。</p>
<p>链表是一种<strong>非线性结构</strong>：其以节点方式存储，节点间在内存上的位置不连续。</p>
<p>链表是有序的列表。单向链表每个节点包含 data 域和 next 域。那些 next 域指向下一节点的位置。</p>
<p>双向链表在单向链表的基础上，每个节点加入 prev 区域以指示其前方节点。这样，就能实现双向查找。双向链表可以不依靠辅助节点而实现自我删除。</p>
<p>LinkedList 底层实现了 双向链表 和 双端队列 特点。在 Java 中，LinkedList 也实现了 Deque 接口。</p>
<p>LinkedList 可以添加 null，可添加重复元素。但没有实现同步，因此线程不安全。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://i-melody.github.io/img/Java_InputImage/%E9%93%BE%E8%A1%A8%E5%9B%BE_13.3.3.webp"><img src="https://i-melody.github.io/img/Java_InputImage/%E9%93%BE%E8%A1%A8%E5%9B%BE_13.3.3.webp" alt="img"></a></p>
<h4 id="常用方法：-2"><a href="#常用方法：-2" class="headerlink" title="#常用方法："></a>#常用方法：</h4><ul>
<li><p><code>void addLast(E e)</code>：尾插一个新的元素</p>
<p>LinkedList 的 add 方法即调用该方法</p>
</li>
<li><p><code>void addFirst(E e)</code>：头插一个新的元素</p>
</li>
<li><p><code>E removeLast()</code>：移除并返回尾部元素。为空时报错</p>
<p><code>E poll()</code>：移除并返回尾部元素。为空时返回 null</p>
<p><code>E removeFirst()</code>：移除并返回头部元素。为空时报错</p>
</li>
<li><p><code>E getLast()</code>：仅返回尾部元素。为空时报错</p>
<p><code>E peek()</code>：返回尾部元素。为空时返回 null</p>
<p><code>E element()</code>：返回头部元素。为空时返回 null</p>
<p><code>E getFirst()</code></p>
</li>
</ul>
<h4 id="LinkedList-的源码"><a href="#LinkedList-的源码" class="headerlink" title="#LinkedList 的源码"></a>#LinkedList 的源码</h4><ol>
<li><p>LinkedList 只有默认构造器和一个拷贝构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>LinkedList 底层维护了一个 双向链表</p>
<p>两个属性 first、last 分别指向 首节点 和 尾节点</p>
<p>每个节点（Node 对象），里面又维护了 prev、next、item 属性。</p>
<p>其中通过 prev 指向前一个节点，通过 next 指向后一个节点。最终实现双向链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>LinkedList 不需要扩容。其增删元素时只要改变节点的指向即可。</p>
<p>也因此，其添加、删除元素效率比数组更高</p>
</li>
</ol>
<h4 id="ArrayList-和-LinkedList-的比较："><a href="#ArrayList-和-LinkedList-的比较：" class="headerlink" title="#ArrayList 和 LinkedList 的比较："></a>#ArrayList 和 LinkedList 的比较：</h4><table>
<thead>
<tr>
<th></th>
<th>底层结构</th>
<th>增删效率</th>
<th>改查效率</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>可变数组</td>
<td>低（数组扩容）</td>
<td>高</td>
</tr>
<tr>
<td><code>LinkedList</code></td>
<td>双向链表</td>
<td>高（链表追加）</td>
<td>低</td>
</tr>
</tbody></table>
<p>应该根据实际情况来选择使用的集合：</p>
<ul>
<li>如果改查操作多，选择 ArrayList。一般来说，在程序中，80% - 90% 都是查询。大部分情况下，选择 ArrayList。</li>
<li>如果增删操作多，选择 LinkedList</li>
</ul>
<h3 id="13-3-4-稀疏数组"><a href="#13-3-4-稀疏数组" class="headerlink" title="13.3.4 稀疏数组"></a>13.3.4 稀疏数组</h3><blockquote>
<p>二维数组的很多值是默认值 0，因此记录了很多没有意义的数据。因此，可以使用稀疏数组。</p>
</blockquote>
<p>稀疏数组的处理方法：</p>
<ol>
<li>记录数组共有几行几列，有多少个不同的值</li>
<li>把具有不同值的元素的行列及值记录在一个小规模数组中，从而缩小程序规模</li>
</ol>
<p><strong>二维数组转换为稀疏数组：</strong></p>
<p>下面用 ArrayList 模拟一个稀疏数组。</p>
<p>二维数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] map = &#123;&#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> ,<span class="number">0</span> , <span class="number">0</span>&#125;,</span><br><span class="line">              &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;,</span><br><span class="line">              &#123;<span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">              &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">              &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">              &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">              &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>遍历原始的二维数组，得到有效数据的个数 sum，并将二维数组的有效数据存入稀疏数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="type">int</span>[]&gt; sparseArray = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">sparseArray.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;map.length, map[<span class="number">0</span>].length, <span class="number">0</span>&#125;);	<span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>; y &lt; map.length; y++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; map[<span class="number">0</span>].length; x++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map[y][x] != <span class="number">0</span>) &#123;</span><br><span class="line">            sparseArray.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;y, x, map[y][x]&#125;);</span><br><span class="line">            sparseArray.get(<span class="number">0</span>)[<span class="number">2</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>稀疏数组转化为二维数组：</strong></p>
<p>读取稀疏数组的每一行，按照其第一行数据，创建原始的二维数组。</p>
<p>读取后几行数据，将值赋给二维数组</p>
<h3 id="13-3-5-栈-Stack"><a href="#13-3-5-栈-Stack" class="headerlink" title="13.3.5 栈 Stack"></a>13.3.5 栈 Stack</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class Stack&lt;E&gt; extends Vector&lt;E&gt;</span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Stack 是 Vector 的子类。以数组模拟了栈的数据结构。</p>
<p>栈是一个先入后出的有序列表。其元素之插入删除只能在该线性表的同一端进行。</p>
<p>其允许增删的一端称为栈顶，另一端即为栈底。</p>
<p>最先放入的元素位于栈底，最后放入的元素位于栈顶。</p>
<p>放入元素称为入栈（push），取出元素称为出栈（pop）</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://i-melody.github.io/img/Java_InputImage/%E6%A0%88%E5%9B%BE_13.3.5.webp"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" alt="img"></a></p>
<p><strong>栈的应用场景：</strong></p>
<ul>
<li>子程序的调用</li>
<li>处理递归调用</li>
<li>表达式的转换与求值</li>
<li>二叉树的遍历</li>
<li>图形的深度优先搜索法</li>
</ul>
<h4 id="常用方法：-3"><a href="#常用方法：-3" class="headerlink" title="#常用方法："></a>#常用方法：</h4><ul>
<li><p><code>E push(E item)</code>：将元素 item 压入栈。返回值是 item 自己</p>
</li>
<li><p><code>E pop()</code>：让栈顶元素出栈</p>
</li>
<li><p><code>E peek()</code>：仅获取栈顶元素</p>
</li>
<li><p><code>int search(Object o)</code>：查找该元素最后出现的位置。</p>
<p>栈底为 1，栈顶为 size()，不存在返回 -1</p>
</li>
</ul>
<h4 id="13-3-5-1-栈模拟计算器"><a href="#13-3-5-1-栈模拟计算器" class="headerlink" title="#13.3.5.1 栈模拟计算器"></a>#13.3.5.1 栈模拟计算器</h4><blockquote>
<p>使用栈结构完成对计算器的实现</p>
</blockquote>
<p>要进行计算，需要获得表达式。</p>
<p>表达式分为三种：</p>
<ul>
<li><p><strong>中缀表达式：</strong></p>
<p>中缀表达式即生活中常见的运算表达式。比如：(3 + 4) * 5 - 6</p>
<p>中缀表达式是人最熟悉的。但是对于计算机来说却不好操作。因此，计算时常将其转化为其他表达式进行操作。</p>
</li>
<li><p><strong>前缀表达式：</strong></p>
<p>前缀表达式（波兰表达式）是一种没有括号的表达式。其将运算符写在前面，操作数写在后面</p>
<blockquote>
<p>(3 + 4) * 5 - 6 的前缀表达式为： + 3 * 4 - 5 6</p>
<p>(1 + 2) * (3 + 4) 的前缀表达式为：* + 1 2 + 3 4</p>
</blockquote>
<p>前缀表达式的计算机求值：</p>
<ul>
<li>从<strong>右</strong>向<strong>左</strong>扫描表达式</li>
<li>将数字压入堆栈</li>
<li>遇到运算符的场合，对数字栈顶元素与次顶元素进行计算，并把那个结果入栈</li>
<li>重复该操作，最终数字栈的唯一剩余数字即为运算结果</li>
</ul>
</li>
<li><p><strong>后缀表达式：</strong></p>
<p>后缀表达式（逆波兰表达式）与前缀表达式相似。但其运算符位于操作数之后</p>
<blockquote>
<p>(3 + 4) * 5 - 6 的后缀表达式为： 3 4 + 5 * 6 -</p>
<p>(1 + 2) * (3 + 4) 的后缀表达式为：1 2 + 3 4 + *</p>
</blockquote>
<p>后缀表达式的计算机求值：</p>
<ul>
<li>从<strong>左</strong>向<strong>右</strong>扫描表达式</li>
<li>将数字压入堆栈</li>
<li>遇到运算符的场合，对数字栈顶元素与次顶元素进行计算，并把那个结果入栈</li>
<li>重复该操作，最终数字栈的唯一剩余数字即为运算结果</li>
</ul>
</li>
</ul>
<p>对于人类来说，中缀表达式最为熟悉。但对于计算机来说，前缀、后缀表达式更容易识别。</p>
<p>我们可以将中缀表达式转化为后缀表达式，再进行运算。</p>
<p><strong>中缀表达式转换为后缀表达式：</strong></p>
<ol>
<li><p>初始化两个栈：运算符栈 operator_stack、表达式栈 formula_stack</p>
</li>
<li><p>从左到右扫描中缀表达式</p>
</li>
<li><p>遇到操作数时，将其压入表达式栈 formula_stack</p>
</li>
<li><p>遇到运算符时，比较其与 operator_stack 栈顶运算符的优先级。</p>
<ul>
<li>operator_stack 为空，或栈顶为 <code>(</code> 的场合，让运算符入栈</li>
<li>优先级高于栈顶运算符的场合，让其入栈</li>
<li>优先级低于或等于栈顶运算符的场合，将那个堆顶运算符弹出并压入 formula_stack。之后，重复该步骤。</li>
</ul>
</li>
<li><p>遇到括号时：</p>
<ul>
<li>遇到 <code>(</code> 时，压入 operator_stack</li>
<li>遇到 <code>)</code> 时，直到遇到 <code>(</code> 前，依次弹出 operator_stack 堆顶的运算符，并压入 formula_stack。之后将这一对括号丢弃。</li>
</ul>
</li>
<li><p>到达表达式最右边时，依次弹出 operator_stack 堆顶的运算符，压入 formula_stack。</p>
</li>
<li><p>此时，formula_stack 即为后缀表达式。</p>
<p>使用 Java 的 toArray 方法将其转为数组。或将其依次弹出，并逆序输出。</p>
</li>
</ol>
<p><strong>计算器的实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Character, Integer&gt; priority = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        priority.put(<span class="string">&#x27;+&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">        priority.put(<span class="string">&#x27;-&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">        priority.put(<span class="string">&#x27;*&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">        priority.put(<span class="string">&#x27;/&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">        priority.put(<span class="string">&#x27;×&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">        priority.put(<span class="string">&#x27;÷&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">        priority.put(<span class="string">&#x27;(&#x27;</span>, -<span class="number">100</span>);</span><br><span class="line">        priority.put(<span class="string">&#x27;)&#x27;</span>, -<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">calculate</span><span class="params">(String formula)</span> &#123;</span><br><span class="line">        String[] ss = formula.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        Stack&lt;String&gt; operator_stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;String&gt; formula_stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : ss) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.matches(<span class="string">&quot;\\d+([.]\\d+)?&quot;</span>)) &#123;</span><br><span class="line">                formula_stack.push(s);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operator_stack.empty() || s.equals(<span class="string">&quot;(&quot;</span>)) &#123;</span><br><span class="line">                operator_stack.push(s);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> operator_stack.peek();</span><br><span class="line">            <span class="keyword">while</span> (priority.get(s.charAt(<span class="number">0</span>)) &lt;= priority.get(temp.charAt(<span class="number">0</span>))) &#123;</span><br><span class="line">                formula_stack.push(operator_stack.pop());</span><br><span class="line">                <span class="keyword">if</span> (operator_stack.empty()) <span class="keyword">break</span>;</span><br><span class="line">                temp = operator_stack.peek();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">&quot;)&quot;</span>)) &#123;</span><br><span class="line">                operator_stack.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> operator_stack.push(s);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!operator_stack.empty()) &#123;</span><br><span class="line">            formula_stack.push(operator_stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> anti_Poland(String.join(<span class="string">&quot; &quot;</span>, formula_stack.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;&#125;)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">anti_Poland</span><span class="params">(String formula)</span> &#123;</span><br><span class="line">        String[] ss = formula.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        Stack&lt;Double&gt; ns = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : ss) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">double</span> <span class="variable">num</span> <span class="operator">=</span> Double.parseDouble(s);</span><br><span class="line">                ns.push(num);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (s) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                        ns.push(ns.pop() + ns.pop());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;×&quot;</span>:</span><br><span class="line">                        ns.push(ns.pop() * ns.pop());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;÷&quot;</span>:</span><br><span class="line">                        ns.push(<span class="number">1</span> / ns.pop() * ns.pop());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                        ns.push(-ns.pop() + ns.pop());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Illegal operator&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ns.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-3-6-跳表-SkipList"><a href="#13-3-6-跳表-SkipList" class="headerlink" title="13.3.6 跳表 SkipList"></a>13.3.6 跳表 SkipList</h3><p>跳表是一种特殊的链表。普通的链表虽然添加、删除节点的速度很快（O(1)），但是要查找节点却很慢（O(n)）。跳表是一个多层次的链表，其在链表的基础上增加了多级索引，实现了 O(㏒n) 的查找速度。</p>
<p>[<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" alt="img">](<a target="_blank" rel="noopener" href="https://i-melody.github.io/img/Java_InputImage/13_3_6">https://i-melody.github.io/img/Java_InputImage/13_3_6</a> 跳表图.webp)</p>
<p><em>（13_3_6 跳表图）</em></p>
<p>跳表将原本数据层的数据按照一定间隔抽取节点形成索引层，之后再从索引层抽取节点形成第二级索引，以此类推形成多层索引。</p>
<p>跳表的查询速度得到了优化，但占用空间更大。本质上是一种空间换时间的做法。</p>
<p><strong>查询</strong></p>
<p>从最稀疏的索引层（最上层）开始，确定那个待查找数据所在的范围，逐层向下并确定范围，直至数据层。</p>
<p><strong>增删</strong></p>
<p>删除元素时，如果那个元素是索引元素，那些索引也会被删除。同时，如果只向数据层中增加元素，可能使索引间隔过大，从而降低查找效率。如果在增加元素时还能保持索引数量的动态平衡，就能防止跳表退化，保持跳表效率。</p>
<p>跳表给出的解决方案是：在增加元素时产生一个随机值，让这个随机值决定该新节点是否成为索引节点，以及成为几级索引节点。</p>
<p><strong>实现跳表</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Skiplist</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> level;					<span class="comment">// 该跳表的合计层数，包括数据层和索引层</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Random seed;					<span class="comment">// 随机数种子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node root;					<span class="comment">// 链表开头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node end;						<span class="comment">// 链表结尾</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;					<span class="comment">// 链表节点类</span></span><br><span class="line">        <span class="type">int</span> val;				<span class="comment">// 值</span></span><br><span class="line">        <span class="type">int</span> count;				<span class="comment">// 储存的值的数量</span></span><br><span class="line">        Node[] next;			<span class="comment">// 指向的下一节点</span></span><br><span class="line">        Node[] prev;			<span class="comment">// 指向的上一节点</span></span><br><span class="line">        						<span class="comment">// 需要指出的是：next 和 prev 的长度指示了节点所在的最高层级</span></span><br><span class="line">        						<span class="comment">// 长度为 1 时仅处在数据层，2 时也位于一级索引，以此类推</span></span><br><span class="line">        						<span class="comment">// 也就是说，next 和 prev 里，下标 0 的位置位于数据层，1 位于一级索引层</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 三个参数是：值 val，节点的层级 rand，节点储存值的数量 count */</span></span><br><span class="line">        Node(<span class="type">int</span> val, <span class="type">int</span> rand, <span class="type">int</span> count) &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.count = count;</span><br><span class="line">            next = <span class="keyword">new</span> <span class="title class_">Node</span>[rand];</span><br><span class="line">            prev = <span class="keyword">new</span> <span class="title class_">Node</span>[rand];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造器 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Skiplist</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 有参构造器。输入的值是索引层数量。该值至少应为 1 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Skiplist</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (level &lt; <span class="number">1</span> || level &gt; <span class="number">30</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(level == <span class="number">0</span> ?</span><br><span class="line">                    <span class="string">&quot;Why not choose a LinkedList?&quot;</span> :</span><br><span class="line">                    <span class="string">&quot;SkipList level out of range: given &quot;</span> + level + <span class="string">&quot; out of range [1, 30]&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.level = level + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">this</span>.seed = <span class="keyword">new</span> <span class="title class_">Random</span>(System.currentTimeMillis());</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node</span>(Integer.MIN_VALUE, <span class="built_in">this</span>.level, <span class="number">0</span>);</span><br><span class="line">        end = <span class="keyword">new</span> <span class="title class_">Node</span>(Integer.MAX_VALUE, <span class="built_in">this</span>.level, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>; n &lt; <span class="built_in">this</span>.level; n++) &#123;</span><br><span class="line">            root.next[n] = end;</span><br><span class="line">            end.prev[n] = root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 查询一个值是否存在 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">find</span> <span class="operator">=</span> position(target);</span><br><span class="line">        <span class="keyword">return</span> find.val == target &amp;&amp; find.count &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 搜索一个值的位置。不存在时会返回数据层中前一个节点的位置 */</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">position</span><span class="params">(<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">see</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (see.val == target) <span class="keyword">return</span> see;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> see.next.length - <span class="number">1</span>; ; n--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span> see;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (see.next[n].val &lt;= target) &#123;</span><br><span class="line">                    see = see.next[n];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 添加一个值 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">pos</span> <span class="operator">=</span> position(num);</span><br><span class="line">        <span class="keyword">if</span> (pos.val == num) &#123;		<span class="comment">// 如果这个节点已经建立，就仅使该节点计数增加</span></span><br><span class="line">            pos.count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="number">1</span> + level - Integer.toBinaryString(seed.nextInt(<span class="number">1</span> &lt;&lt; level)).length();</span><br><span class="line">        			<span class="comment">// level 的值等于总层数。seed 是一个随机数种子，nextInt(int n) 方法返回 [0, n) 的数值</span></span><br><span class="line">        			<span class="comment">// Integer.toBinaryString(int n) 方法是将一个数字转化成二进制表示的字符串</span></span><br><span class="line">        			<span class="comment">// seed.nextInt(1 &lt;&lt; level) 保证了返回值的二进制长度在 [1, level] 之间，并且概率合意</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">add</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(num, rand, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>; t &lt; rand; ) &#123;			<span class="comment">// 将新节点添加到链表中。</span></span><br><span class="line">            <span class="keyword">for</span> (; t &lt; pos.next.length &amp;&amp; t &lt; rand; t++) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> pos.next[t];</span><br><span class="line">                add.next[t] = next;</span><br><span class="line">                next.prev[t] = add;</span><br><span class="line">                pos.next[t] = add;</span><br><span class="line">                add.prev[t] = pos;</span><br><span class="line">            &#125;</span><br><span class="line">            pos = pos.prev[pos.prev.length - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 删除节点（的值） */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">erase</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">pos</span> <span class="operator">=</span> position(num);</span><br><span class="line">        <span class="keyword">if</span> (pos.val == num &amp;&amp; pos.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            pos.count--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-5-双列集合接口-Map"><a href="#13-5-双列集合接口-Map" class="headerlink" title="13.5 双列集合接口 Map"></a>13.5 双列集合接口 Map</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Map</span>&lt;K,V&gt;</span><br></pre></td></tr></table></figure>

<p><strong>以下关于 Map 接口的描述，适用于 JDK 8 的环境</strong></p>
<blockquote>
<p>Map 与 Collection 并列存在，用于保存具有映射关系的数据：key - value（双列元素）</p>
<p>Map 的 key 和 value 可以是任何类型的引用数据类型，也能存入 null。</p>
<p>Map 的 key 不允许重复，value 可以重复。key 和 value 存在单一对应关系。通过特定的 key 一定能找到指定的 value。</p>
<p>一组 k - v 会被封装到一个 Entry 对象中。Entry 是一个内部接口。Map 的实现子类中都包含一个实现这个接口的内部类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Entry</span>&lt;K,V&gt; &#123;</span><br><span class="line">	K <span class="title function_">getKey</span><span class="params">()</span>;</span><br><span class="line">	V <span class="title function_">getValue</span><span class="params">()</span>;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果添加相同的 key，会覆盖原先的 key -value。等同于修改（key 不会替换，value 会被替换）</p>
</blockquote>
<h4 id="常用方法：-4"><a href="#常用方法：-4" class="headerlink" title="#常用方法："></a>#常用方法：</h4><ul>
<li><p><code>put()</code>：添加。已存在的场合，实行替换。（key 不替换，value 替换）</p>
</li>
<li><p><code>remove()</code>：根据键删除映射关系</p>
</li>
<li><p><code>get()</code>：根据键获取值</p>
</li>
<li><p><code>size()</code>：元素个数</p>
</li>
<li><p><code>isEmpty()</code>：判断个数是否为 0</p>
</li>
<li><p><code>clear()</code>：清空</p>
</li>
<li><p><code>containsKey()</code>：查找键是否存在</p>
</li>
<li><p><code>Set&lt;K&gt; keySet()</code>：获取所有 键 构成的集合</p>
<p><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>：获取所有 Entry 构成的集合</p>
<p><code>Collection&lt;V&gt; values()</code>：获取所有 值 构成的集合</p>
</li>
</ul>
<h4 id="Map-接口遍历元素："><a href="#Map-接口遍历元素：" class="headerlink" title="#Map 接口遍历元素："></a>#Map 接口遍历元素：</h4><ul>
<li><p><strong>方法一</strong>：利用 <code>Set&lt;K&gt; keySet()</code> 方法</p>
<p>先得到所有 keys，再遍历 keys，根据每个 key 获得 value：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">keyset</span> <span class="operator">=</span> map.keySet();</span><br><span class="line"><span class="comment">//增强for</span></span><br><span class="line"><span class="keyword">for</span> (Object key : keyset) &#123;</span><br><span class="line">	System.out.println(key + <span class="string">&quot; - &quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line"><span class="type">Iterrator</span> <span class="variable">iterrator</span> <span class="operator">=</span> keyset.iterrator();</span><br><span class="line"><span class="keyword">while</span> (iterrator.hasNext()) &#123;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> iterrator.next();</span><br><span class="line">    System.out.println(key + <span class="string">&quot; - &quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>方法二</strong>：利用 <code>Set&lt;V&gt; values()</code> 方法</p>
<p>直接把所有 values 取出，之后遍历 values</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();</span><br><span class="line"><span class="keyword">for</span> (Object value : values) &#123;</span><br><span class="line">	System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>方法三</strong>：利用 <code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code> 方法</p>
<p>通过获取 entrySet 来获取 k - v</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Map.Entry&gt; entrySet = map.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry e : entrySet) &#123;</span><br><span class="line">	System.out.println(e.getKey() + <span class="string">&quot; - &quot;</span> + e.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="13-5-1-散列表-HashMap"><a href="#13-5-1-散列表-HashMap" class="headerlink" title="13.5.1 散列表 HashMap"></a>13.5.1 散列表 HashMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>

<blockquote>
<p>HashMap 是 Map 接口使用频率最高的实现类。是根据关键码值（key value）而进行直接访问的数据结构。通过将关键码值映射到表中一个位置来访问记录，以加快查找速度。</p>
<p>那个映射函数叫做散列函数，存放记录的数组叫做散列表（哈希表）</p>
<p>HashMap 是以 k - v 对得到方式来存储数据。一组数据会被封装到一个 Node 对象中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line"><span class="keyword">final</span> K key;</span><br><span class="line">V value;</span><br><span class="line">Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK 7 前，HashMap 底层是 数组 + 链表。JDK 8 后，底层是 数组 + 链表 + 红黑树。HashMap 不保证映射的顺序。</p>
<p>HashMap 没有实现同步（没有 synchronized），是线程不安全的</p>
</blockquote>
<h4 id="HashMap-的源码："><a href="#HashMap-的源码：" class="headerlink" title="#HashMap 的源码："></a>#HashMap 的源码：</h4><ol>
<li><p>HashMap 底层维护了 Node 类型的数组 table。默认为 null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>

<p>另外，还有集合 values、keySet、enrtySet。这些集合能帮助程序员进行遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Set&lt;K&gt;				keySet;</span><br><span class="line"><span class="keyword">transient</span> Collection&lt;V&gt;			values;</span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt;	entrySet;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建对象时，默认构造器将加载因子（loadfactor）初始化为 0.75。</p>
<p>也能指定那些初始容量和加载因子。</p>
<p>默认构造器第一次添加元素的场合，table 扩容为 16，临界值为 16 * 0.75 &#x3D; 12。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;					<span class="comment">// 这个默认构造的场合，其他参数都是默认值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(...);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(...);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加时容量不够的场合，需要扩容。</p>
<p>默认构造器第一次添加元素的场合，table 扩容为 16，临界值为 16 * 0.75 &#x3D; 12。</p>
<p>扩容的场合，容量变为 2 倍。临界值相应变化（即变成24）。</p>
<p>临界值不会超过那个指定的 MAXIMUM_CAPACITY（1 &lt;&lt; 30），否则变成 Integer.MAX_VALUE。</p>
<p>JDK 8 中，<strong>如果一条链表的元素个数超过 TREEIFY_THRESHOLD（默认是 8），并且 <code>table</code> 的大小 &gt;&#x3D; MIN_TREEIFY_CAPACITY（默认 64）</strong>，会进行树化，否则仍采用数组扩容机制。</p>
<p>剪枝：红黑树的元素减少到一定程度，会被重新转化为 链表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;								<span class="comment">// &lt;- 旧的数据数组 table</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;		<span class="comment">// &lt;- 旧的 table 的容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;									<span class="comment">// &lt;- 旧的临界值</span></span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;									<span class="comment">// &lt;- 新的容量、临界值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 旧的数组不为空时，</span></span><br><span class="line"><span class="comment">    	如果容量已达指定的 MAXIMUM_CAPACITY，则不扩容</span></span><br><span class="line"><span class="comment">    	否则扩容为 2 倍容量，临界值也变为 2 倍 */</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        newCap = oldCap &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 旧的数组为空，但临界值已被指定（原因是：指定构造器传入初始容量为 0） */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">/* 旧的数组为空，临界值为 0（原因是：使用默认构造器）</span></span><br><span class="line"><span class="comment">    	默认构造器初始化容量为 16，默认临界因子为 0.75f */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 到这里，newThr（新临界值）为 0 的原因可能是：</span></span><br><span class="line"><span class="comment">    	1. 旧容量小于那个最小容量（16）</span></span><br><span class="line"><span class="comment">    	2. 扩容后容量大于那个最大容量</span></span><br><span class="line"><span class="comment">    	3. 旧的临界值为 0 或 Integer.MIN_VALUE</span></span><br><span class="line"><span class="comment">    	4. 构造器传入初始容量为 0 */</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 按照 新容量 * 临界因子 的方法计算临界值。临界值不会超过一个指定的最大值 */</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 确定了容量和临界值，下面把旧数组元素移至新数组。</span></span><br><span class="line"><span class="comment">    	那个移动的场合，会以新容量重新计算所有元素的下标位置 */</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加 k - v 时，通过 key 的哈希值得到其在 table 的索引，判断索引位置是否被占用。</p>
<p>未占用的场合，直接添加。</p>
<p>占用的场合，判断其 key 是否相等。相等的场合，替换 value。否则，按照 树 或 链表 的方式处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 会先对放入元素的哈希值进行一次计算，得到一个数字：hash */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h ^ (h &gt;&gt;&gt; <span class="number">16</span>));	<span class="comment">// 位运算符：&gt;&gt;&gt; 无符号右移</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* put 方法会调用该 putVal 方法。</span></span><br><span class="line"><span class="comment">	那些传入值是：	hash、	key、	value、			false、				true */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab = table; 		<span class="comment">// &lt;- 是那个存放数据的 table 数组</span></span><br><span class="line">    <span class="type">int</span> n;							<span class="comment">// &lt;- 是 table.length</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 如果原先的 table 为空，则对其重新分配空间 */</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">        tab = resize();</span><br><span class="line">        n = tab.length;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 用方才计算的 hash 数，得到要放入元素的下标值 i</span></span><br><span class="line"><span class="comment">    	n - 1 是数据数组的最大下标，(n - 1) &amp; hash 必定不大于 n - 1 */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (n - <span class="number">1</span>) &amp; hash;			<span class="comment">// 位运算符：&amp; 按位与</span></span><br><span class="line">    Node&lt;K,V&gt; p = tab[i];			<span class="comment">// 得到 table 中，位于那个插入位置的元素</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 倘若该位置为空，则直接放入 */</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 该位置不为空，意味着可能添加了重复元素 */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; 			<span class="comment">// &lt;- 被发现重复的那个 Node。无重复时结果为 null。这个 Node 的 value 会被替换。</span></span><br><span class="line">        <span class="type">K</span> <span class="variable">k</span> <span class="operator">=</span> p.key;			<span class="comment">// &lt;- 当前取出进行比较的 key 值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 为了验证其是否重复，这里要进行如下比较：</span></span><br><span class="line"><span class="comment">        	1. 比较两者的 hash 数。不同的场合是不同元素</span></span><br><span class="line"><span class="comment">        	2. 使用 == 和 equals 两种方法比较 key。不同的场合是不同元素 </span></span><br><span class="line"><span class="comment">        	如果是相同元素，则该节点的值会被替换 */</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; (k  == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">            e = p;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 此处节点结构是 树 的场合，还需遍历比较树的每个节点 */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 此处节点结构是 链表 的场合，还需遍历比较每个链表节点 */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                e = p.next;</span><br><span class="line">                <span class="comment">/* e == null 意味着遍历结束，全部不同。这样，在此处添加那个新的 Node */</span></span><br><span class="line">                <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* 故技重施，如果发现相同，则替换那个新元素 */</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 经历上述比较后，e != null 意味着有元素要被替换了 */</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">/* 传入的参数 onluIfAbsent == false，所以此处一定是 true */</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);		<span class="comment">// &lt;- HashMap 中，该方法为空实现。</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 如果到达这里，说明添加了元素（而非替换），要查看大小是否超过临界值 */</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);		<span class="comment">// &lt;- HashMap 中，该方法为空实现。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上面提到的一些空实现的方法 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> &#123; &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123; &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> &#123; &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="13-5-2-散列表-Hashtable"><a href="#13-5-2-散列表-Hashtable" class="headerlink" title="13.5.2 散列表 Hashtable"></a>13.5.2 散列表 Hashtable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hashtable</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Dictionary</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Hashtable 和 HashMap 基本一致，但Hashtable 是线程安全的 。但也因为如此，Hashtable 的效率低下。</p>
</blockquote>
<h4 id="Hashtable-与-HashMap-的比较："><a href="#Hashtable-与-HashMap-的比较：" class="headerlink" title="#Hashtable 与 HashMap 的比较："></a>#Hashtable 与 HashMap 的比较：</h4><table>
<thead>
<tr>
<th></th>
<th>版本</th>
<th>线程安全（同步）</th>
<th>效率</th>
<th>是否允许 null值</th>
</tr>
</thead>
<tbody><tr>
<td>Hashtable</td>
<td>1.0</td>
<td>安全</td>
<td>较低</td>
<td>不允许</td>
</tr>
<tr>
<td>HashMap</td>
<td>1.2</td>
<td>不安全</td>
<td>高</td>
<td>允许</td>
</tr>
</tbody></table>
<ul>
<li><p>Hashtable 底层也是有数组，默认构造器的初始容量为 11。临界值是 11 * 0.75 &#x3D; 8。</p>
</li>
<li><p>扩容大致如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;	<span class="comment">//即，原容量 * 2 + 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Hashtable 不会树化</p>
</li>
</ul>
<h3 id="13-5-3-红黑树-TreeMap"><a href="#13-5-3-红黑树-TreeMap" class="headerlink" title="13.5.3 红黑树 TreeMap"></a>13.5.3 红黑树 TreeMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">NavigableMap</span>&lt;K,V&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>

<blockquote>
<p>TreeMap 实现了 Map 接口。底层使用 红黑树 存储数据。</p>
<p>相较数组（访问快，检索、插入慢）和链表（插入快，检索、访问慢），树形数据结构（如二叉排序树）在保证数据检索速度的同时，也能保证数据插入、删除、修改的速度</p>
</blockquote>
<p><em><strong>——见 [[14.1.4.1 平衡二叉树]](<a target="_blank" rel="noopener" href="https://i-melody.github.io/2022/06/02/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/14">https://i-melody.github.io/2022/06/02/Java/入门阶段/14</a> 树&#x2F;#14-1-4-1-平衡二叉树)</strong></em></p>
<h4 id="TreeMap-的源码："><a href="#TreeMap-的源码：" class="headerlink" title="#TreeMap 的源码："></a>#TreeMap 的源码：</h4><ol>
<li><p>TreeMap 底层维护了一个二叉树，以及一个比较器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建对象时，能采用无参构造，也能指定比较器完成构造</p>
<p>那个无参构造的场合，比较器为空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">()</span> &#123;</span><br><span class="line">    comparator = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> K&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较器如果为空，则要求传入的 key 必须是 Comparable 接口的实现子类，否则无法进行比较。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object k1, Object k2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> comparator==<span class="literal">null</span> ? ((Comparable&lt;? <span class="built_in">super</span> K&gt;)k1).compareTo((K)k2)</span><br><span class="line">        : comparator.compare((K)k1, (K)k2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加时，通过比较器确定那个添加位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root;	// &lt;- 树的根节点</span><br><span class="line">    </span><br><span class="line">    /* 二叉树为空的场合，创建根节点，将数据放入 */</span><br><span class="line">    if (t == null) &#123;</span><br><span class="line">        compare(key, key);//检测key是否为空(抛异常)</span><br><span class="line">        root = new Entry&lt;&gt;(key, value, null);</span><br><span class="line">        size = 1;</span><br><span class="line">        modCount++;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int cmp;				// &lt;- 临时值，存放比较结果</span><br><span class="line">    Entry&lt;K,V&gt; parent;		// &lt;- 临时值，存放父节点</span><br><span class="line">    Comparator&lt;? super K&gt; cpr = comparator;		// &lt;- 比较器</span><br><span class="line">    </span><br><span class="line">    /* 有比较器的场合，按照这个方法进行比较 */</span><br><span class="line">    if (cpr != null) &#123;</span><br><span class="line">        do &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            if (cmp &lt; 0)</span><br><span class="line">                t = t.left;</span><br><span class="line">            else if (cmp &gt; 0)</span><br><span class="line">                t = t.right;</span><br><span class="line">            else</span><br><span class="line">                return t.setValue(value);//value替换</span><br><span class="line">        &#125; while (t != null);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /* 比较器为空的场合，按照这个方法进行比较 */</span><br><span class="line">    else &#123;</span><br><span class="line">        if (key == null) &#123;</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;</span><br><span class="line">        do &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = k.compareTo(t.key);</span><br><span class="line">            if (cmp &lt; 0)</span><br><span class="line">                t = t.left;</span><br><span class="line">            else if (cmp &gt; 0)</span><br><span class="line">                t = t.right;</span><br><span class="line">            else</span><br><span class="line">                return t.setValue(value);</span><br><span class="line">        &#125; while (t != null);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /* 将数据节点放到正确的路径下 */</span><br><span class="line">    Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);</span><br><span class="line">    if (cmp &lt; 0)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    else</span><br><span class="line">        parent.right = e;</span><br><span class="line">    </span><br><span class="line">    /* 此处会试着将该树转换成完全二叉树 */</span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加的最后，会试着将该树转换成完全二叉树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> &#123;</span><br><span class="line">    x.color = RED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateLeft(x);</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                rotateRight(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateRight(x);</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="13-5-4-Properties"><a href="#13-5-4-Properties" class="headerlink" title="13.5.4 Properties"></a>13.5.4 Properties</h3><blockquote>
<p>Properties 继承自 Hashtable 并实现了 Map 接口。也使用键值对的方式保存数据</p>
<p>Properties 使用特点与 Hashtable 相似</p>
<p>Properties 还可以用于 xxx.properties 文件中，加载数据到 Properties 对象，进行读取和修改</p>
<p>xxx.properties 文件常作为配置文件</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Properties</span> <span class="keyword">extends</span> <span class="title class_">Hashtable</span>&lt;Object,Object&gt;</span><br></pre></td></tr></table></figure>

<p><em><strong>——关于这些，详见 [[17 IO流 ]](<a target="_blank" rel="noopener" href="https://i-melody.github.io/2022/01/06/Java/%E5%85%A5%E9%97%A8%E9%98%B6%E6%AE%B5/17">https://i-melody.github.io/2022/01/06/Java/入门阶段/17</a> IO流&#x2F;)</strong></em></p>
<ul>
<li><p><code>String getProperty(String key)</code> ：输入一个 String 类型的 key，返回一个 String 的 value</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getProperty</span><span class="params">(String key)</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">oval</span> <span class="operator">=</span> <span class="built_in">super</span>.get(key);</span><br><span class="line"><span class="type">String</span> <span class="variable">sval</span> <span class="operator">=</span> (oval <span class="keyword">instanceof</span> String) ? (String)oval : <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">return</span> ((sval == <span class="literal">null</span>) &amp;&amp; (defaults != <span class="literal">null</span>)) ? defaults.getProperty(key) : sval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="13-6-无序集合接口-Set"><a href="#13-6-无序集合接口-Set" class="headerlink" title="13.6 无序集合接口 Set"></a>13.6 无序集合接口 Set</h2><blockquote>
<h4 id="Set-是-Collection-接口的子类接口。"><a href="#Set-是-Collection-接口的子类接口。" class="headerlink" title="Set 是 Collection 接口的子类接口。"></a>Set 是 Collection 接口的子类接口。</h4><p>Set 接口的特点是无序（添加和取出顺序不一致，其取出顺序由某个算法决定），没有索引</p>
<p>不允许重复元素。故而，最多包含一个 null</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Set</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>

<h4 id="Set-的遍历"><a href="#Set-的遍历" class="headerlink" title="#Set 的遍历"></a>#Set 的遍历</h4><ol>
<li><p>使用迭代器</p>
</li>
<li><p>增强for</p>
</li>
</ol>
<h3 id="13-6-1-HashSet"><a href="#13-6-1-HashSet" class="headerlink" title="13.6.1 HashSet"></a>13.6.1 HashSet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>

<blockquote>
<p>HashSet 实现了 Set 接口。底层实际上使用 HashMap 来存储数据。</p>
<p>HashSet 是无序的。其实际顺序取决于计算得到的 hash 值</p>
</blockquote>
<blockquote>
<h6 id="底层机制说明："><a href="#底层机制说明：" class="headerlink" title="底层机制说明："></a>底层机制说明：</h6><p>1.HashSet底层是HashMap</p>
<p>2.添加一个元素时，先得到hash值-会转成-&gt;索引值</p>
<p>3.找到存储数据表table，看这个索引位置是否已经存放的有元素</p>
<p>4.如果没有，直接加入</p>
<p>5.如果有，调用equals比较，如果相同，就放弃添加，如果不相同，则添加到最后</p>
<p>6.在Java8中，如果一条链表的元素个数超过TREEIFY THRESHOLD(默认是8)，并且table的大小 &gt;&#x3D;MIN TREEIFY CAPACITY(默认64),就会进行树化(红黑树)</p>
</blockquote>
<h4 id="HashSet-的源码"><a href="#HashSet-的源码" class="headerlink" title="#HashSet 的源码"></a>#HashSet 的源码</h4><ol>
<li><p>HashSet 底层是 HashMap。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例化也和 HashMap 相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加一个元素时调用 HashMap 的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="C:\Users\18356\AppData\Roaming\Typora\typora-user-images\image-20230927144400581.png" alt="image-20230927144400581"></p>
<h3 id="13-6-2-LinkedHashSet"><a href="#13-6-2-LinkedHashSet" class="headerlink" title="13.6.2 LinkedHashSet"></a>13.6.2 LinkedHashSet</h3><blockquote>
<p>LinkedHashSet 是 HashSet 的子类</p>
<p>LinkedHashSet 底层是一个 LinkedHashMap，维护了一个数组 + <strong>双向链表</strong>。（ LinkedHashMap有head和tail）</p>
<p>数组是HashMap$Node[] </p>
<p>存放的元素&#x2F;数据是LinkedHashMap$Entry类型</p>
<p>LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置。同时，使用链表维护元素的次序。这使得元素看起来是以插入顺序保存的，并得以按照放入顺序取出</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>

<h4 id="LinkedHashSet-的源码："><a href="#LinkedHashSet-的源码：" class="headerlink" title="#LinkedHashSet 的源码："></a>#LinkedHashSet 的源码：</h4><ol>
<li><p>在类 HashSet 中，存在一个默认访问范围的构造器。该构造器不同于其他构造器，会让实例维护一个 LinkedHashMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashSet(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedHashSet 的构造器即调用了该父类构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity, loadFactor, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity, <span class="number">.75f</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="number">16</span>, <span class="number">.75f</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="13-6-3-TreeSet"><a href="#13-6-3-TreeSet" class="headerlink" title="13.6.3 TreeSet"></a>13.6.3 TreeSet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">NavigableSet</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>

<blockquote>
<p>TreeSet 实现了 Set 接口，其底层是一个 TreeMap。</p>
<p>调用无参构造器创建 TreeSet 时，默认是无序排列。也能在构造时传入一个比较器。有比较器的场合，比较器返回 0 时，不发生替换</p>
<p>不传入比较器的场合，使用的是传入对象自带的比较器。所以，这个场合，传入的 key 对象必须是 Comparable 接口的实现子类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TreeSet</span> <span class="variable">treeset</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>()) &#123;</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="comment">//下面调用String的compareTo方法进行字符串大小比较(从小到大)</span></span><br><span class="line">        <span class="comment">//字符串相同无法加入</span></span><br><span class="line">        <span class="keyword">return</span> ((String) o2).compareTo((String) o1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//按字符串长度（从小到大）</span></span><br><span class="line">        <span class="comment">//长度相等无法加入</span></span><br><span class="line">        <span class="keyword">return</span> ((String) o1).length()-((String) o2).length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\18356\AppData\Roaming\Typora\typora-user-images\image-20230927143728318.png" alt="image-20230927143728318"></p>
<h2 id="13-7-集合的选择"><a href="#13-7-集合的选择" class="headerlink" title="13.7 集合的选择"></a>13.7 集合的选择</h2><p>在开发中，选择什么集合实现类，主要取决于业务操作特点，然后根据集合实现类特性进行分析选择。</p>
<p>判断存储的类型（一组对象 [单列]，或一组键值对 [双列]）</p>
<ul>
<li>一组对象：Collection 接口<ul>
<li>允许重复：List<ul>
<li>增删多：<code>LinkedList</code> （双向链表）</li>
<li>改查多：ArrayList （<code>Object[]</code> 数组）</li>
</ul>
</li>
<li>不允许重复：Set<ul>
<li>无序：HashSet （数组 + 链表 + 红黑树，底层是 HashMap）</li>
<li>排序：<code>TreeSet</code></li>
<li>顺序一致：LinkedHashSet （数组 + 双向链表，底层是 <code>LinkedHashMap</code>）</li>
</ul>
</li>
</ul>
</li>
<li>一组键值对：Map<ul>
<li>键无序：HashMap （数组 + 链表 + 红黑树 [ JDK 8 以后 ] ）</li>
<li>键排序：<code>TreeMap</code></li>
<li>键顺序一致：<code>LinkedHashMap</code> （底层是 HashMap）</li>
<li>读取文件：Properties</li>
</ul>
</li>
</ul>
<h2 id="13-8-工具类-Collections"><a href="#13-8-工具类-Collections" class="headerlink" title="13.8 工具类 Collections"></a>13.8 工具类 Collections</h2><blockquote>
<p>Collections 工具类是一个操作 Set、List、Map 等集合的工具类</p>
<p>其中提供了一系列静态方法，对集合元素进行 排序、查询和修改等操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.方法名();</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="常用方法：-5"><a href="#常用方法：-5" class="headerlink" title="#常用方法："></a>#常用方法：</h4><p><strong>排序：</strong></p>
<ul>
<li><code>reverse(List)</code>：反转 List 中元素的排序</li>
<li><code>shuffle(List)</code>：对 <code>List </code>中元素进行随机排序</li>
<li><code>sort(List)</code>：根据元素的自然顺序对指定 List 集合元素升序排列</li>
<li><code>reverse(List, Comparator)</code>：根据指定 Comparator 对 List 排序</li>
<li><code>swap(List, int, int)</code>：将两处元素位置互换</li>
</ul>
<p><strong>查找、替换：</strong></p>
<ul>
<li><p><code>Object max(Collection)</code>：根据元素的自然排序，返回集合中最大的元素</p>
</li>
<li><p><code>Object max(Collection, Comparator)</code>：根据比较器，返回最大元素</p>
</li>
<li><p><code>Object min(Collection)</code>：根据元素的自然排序，返回最小元素</p>
</li>
<li><p><code>Object min(Collection, Comparator)</code>：根据比较器，返回最小元素</p>
</li>
<li><p><code>int frequency(Collection, Object)</code>：返回集合中指定元素的出现次数</p>
</li>
<li><p><code>void copy(List dest, List src)</code>：将 src 的内容复制到 dest 中</p>
<p>这个场合，要保证 dest 的大小不小于 src。所以，可能需要先给 dest 赋值</p>
</li>
<li><p><code>boolean replaceAll(List list, Object oldVal, Object newVal)</code>：用 newVal 替换所有 oldVal 值</p>
</li>
</ul>
<h2 id="13-9-JUnit"><a href="#13-9-JUnit" class="headerlink" title="13.9 JUnit"></a>13.9 JUnit</h2><blockquote>
<p>一个类有多个功能代码需要测试，为了测试，就要写入 <code>main</code> 方法中</p>
<p>如果有多个功能代码测试，需要反复撤销，过程繁琐</p>
</blockquote>
<blockquote>
<p>JUnit 是一个 Java 语言单元测试框架</p>
<p>多数 Java 开发环境都已集成了 JUnit 作为单元测试工具</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1fh411y7R8?p=566&t=259.3">使用方法</a></p>
<p>……总的来讲，方法就是加入 <code>@Test</code>，然后 <code>alt + enter</code> 引入 JUnit 5，最后运行</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Hou</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/09/22/%E9%9B%86%E5%90%88/">http://example.com/2023/09/22/%E9%9B%86%E5%90%88/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">焦</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/tx.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/29/%E7%BA%BF%E7%A8%8B/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2023/09/14/%E7%B1%BB/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/tx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Hou</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#13-Java-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">13 Java 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-1-%E9%9B%86%E5%90%88%E7%9A%84%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB"><span class="toc-text">13.1 集合的框架体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2-%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88%E6%8E%A5%E5%8F%A3-Collection"><span class="toc-text">13.2 单列集合接口 Collection</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-text">常用方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-1-%E8%BF%AD%E4%BB%A3%E5%99%A8-Iterator"><span class="toc-text">13.2.1 迭代器 Iterator</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-3-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E6%8E%A5%E5%8F%A3-List"><span class="toc-text">13.3 有序集合接口 List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A-1"><span class="toc-text">常用方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-1-%E5%8F%AF%E5%8F%98%E6%95%B0%E7%BB%84-ArrayList"><span class="toc-text">13.3.1 可变数组 ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList-%E7%9A%84%E6%BA%90%E7%A0%81%EF%BC%9A-%E6%B2%A1%E7%9C%8B"><span class="toc-text">#ArrayList 的源码：&#x2F;&#x2F;没看</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-2-%E5%8F%AF%E5%8F%98%E6%95%B0%E7%BB%84-Vector"><span class="toc-text">13.3.2 可变数组 Vector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector-%E7%9A%84%E6%BA%90%E7%A0%81%EF%BC%9A"><span class="toc-text">#Vector 的源码：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-3-%E9%93%BE%E8%A1%A8-LinkedList"><span class="toc-text">13.3.3 链表 LinkedList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A-2"><span class="toc-text">#常用方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedList-%E7%9A%84%E6%BA%90%E7%A0%81"><span class="toc-text">#LinkedList 的源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList-%E5%92%8C-LinkedList-%E7%9A%84%E6%AF%94%E8%BE%83%EF%BC%9A"><span class="toc-text">#ArrayList 和 LinkedList 的比较：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-4-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84"><span class="toc-text">13.3.4 稀疏数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-5-%E6%A0%88-Stack"><span class="toc-text">13.3.5 栈 Stack</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A-3"><span class="toc-text">#常用方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-5-1-%E6%A0%88%E6%A8%A1%E6%8B%9F%E8%AE%A1%E7%AE%97%E5%99%A8"><span class="toc-text">#13.3.5.1 栈模拟计算器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-6-%E8%B7%B3%E8%A1%A8-SkipList"><span class="toc-text">13.3.6 跳表 SkipList</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-5-%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%88%E6%8E%A5%E5%8F%A3-Map"><span class="toc-text">13.5 双列集合接口 Map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A-4"><span class="toc-text">#常用方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Map-%E6%8E%A5%E5%8F%A3%E9%81%8D%E5%8E%86%E5%85%83%E7%B4%A0%EF%BC%9A"><span class="toc-text">#Map 接口遍历元素：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-5-1-%E6%95%A3%E5%88%97%E8%A1%A8-HashMap"><span class="toc-text">13.5.1 散列表 HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap-%E7%9A%84%E6%BA%90%E7%A0%81%EF%BC%9A"><span class="toc-text">#HashMap 的源码：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-5-2-%E6%95%A3%E5%88%97%E8%A1%A8-Hashtable"><span class="toc-text">13.5.2 散列表 Hashtable</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Hashtable-%E4%B8%8E-HashMap-%E7%9A%84%E6%AF%94%E8%BE%83%EF%BC%9A"><span class="toc-text">#Hashtable 与 HashMap 的比较：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-5-3-%E7%BA%A2%E9%BB%91%E6%A0%91-TreeMap"><span class="toc-text">13.5.3 红黑树 TreeMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeMap-%E7%9A%84%E6%BA%90%E7%A0%81%EF%BC%9A"><span class="toc-text">#TreeMap 的源码：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-5-4-Properties"><span class="toc-text">13.5.4 Properties</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-6-%E6%97%A0%E5%BA%8F%E9%9B%86%E5%90%88%E6%8E%A5%E5%8F%A3-Set"><span class="toc-text">13.6 无序集合接口 Set</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Set-%E6%98%AF-Collection-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AD%90%E7%B1%BB%E6%8E%A5%E5%8F%A3%E3%80%82"><span class="toc-text">Set 是 Collection 接口的子类接口。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Set-%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">#Set 的遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-6-1-HashSet"><span class="toc-text">13.6.1 HashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-text">底层机制说明：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashSet-%E7%9A%84%E6%BA%90%E7%A0%81"><span class="toc-text">#HashSet 的源码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-6-2-LinkedHashSet"><span class="toc-text">13.6.2 LinkedHashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedHashSet-%E7%9A%84%E6%BA%90%E7%A0%81%EF%BC%9A"><span class="toc-text">#LinkedHashSet 的源码：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-6-3-TreeSet"><span class="toc-text">13.6.3 TreeSet</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-7-%E9%9B%86%E5%90%88%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">13.7 集合的选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-8-%E5%B7%A5%E5%85%B7%E7%B1%BB-Collections"><span class="toc-text">13.8 工具类 Collections</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A-5"><span class="toc-text">#常用方法：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-9-JUnit"><span class="toc-text">13.9 JUnit</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Hou</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>